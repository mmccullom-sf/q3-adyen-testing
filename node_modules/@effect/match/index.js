"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.whenOr = exports.whenAnd = exports.when = exports.valueTags = exports.value = exports.unsafe = exports.undefined = exports.typeTags = exports.type = exports.tagsExhaustive = exports.tags = exports.tag = exports.string = exports.safe = exports.record = exports.orElseAbsurd = exports.orElse = exports.option = exports.number = exports.null = exports.not = exports.nonEmptyString = exports.is = exports.instanceOfUnsafe = exports.instanceOf = exports.exhaustive = exports.either = exports.discriminatorsExhaustive = exports.discriminators = exports.discriminator = exports.defined = exports.date = exports.boolean = exports.bigint = exports.any = exports.SafeSchemaId = void 0;
var E = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Either"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var _Pipeable = /*#__PURE__*/require("@effect/data/Pipeable");
var P = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Predicate"));
var S = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/schema/Schema"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 */

class TypeMatcherImpl {
  constructor(cases) {
    this.cases = cases;
    this._tag = "TypeMatcher";
    this._input = _Function.identity;
    this._filters = _Function.identity;
    this._remaining = _Function.identity;
    this._result = _Function.identity;
  }
  add(_case) {
    return new TypeMatcherImpl([...this.cases, _case]);
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
class ValueMatcherImpl {
  constructor(provided, value) {
    this.provided = provided;
    this.value = value;
    this._tag = "ValueMatcher";
    this._input = _Function.identity;
    this._filters = _Function.identity;
    this._result = _Function.identity;
  }
  add(_case) {
    if (this.value._tag === "Right") {
      // @ts-expect-error
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return new ValueMatcherImpl(this.provided, E.right(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return new ValueMatcherImpl(this.provided, E.right(_case.evaluate(this.provided)));
    }
    // @ts-expect-error
    return this;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
class When {
  constructor(guard, evaluate) {
    this.guard = guard;
    this.evaluate = evaluate;
    this._tag = "When";
  }
}
class Not {
  constructor(guard, evaluate) {
    this.guard = guard;
    this.evaluate = evaluate;
    this._tag = "Not";
  }
}
const makePredicate = pattern => {
  if (typeof pattern === "function") {
    return pattern;
  } else if (Array.isArray(pattern)) {
    const predicates = pattern.map(makePredicate);
    const len = predicates.length;
    return u => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern !== null && typeof pattern === "object") {
    if (S.isSchema(pattern)) {
      const validate = S.validateEither(pattern);
      return u => validate(u, {
        onExcessProperty: "ignore"
      })._tag === "Right";
    }
    const keysAndPredicates = Object.entries(pattern).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return u => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return u => u === pattern;
};
const makeOrPredicate = patterns => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
};
const makeAndPredicate = patterns => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
};
/**
 * @category constructors
 * @since 1.0.0
 */
const type = () => new TypeMatcherImpl([]);
/**
 * @category constructors
 * @since 1.0.0
 */
exports.type = type;
const value = i => new ValueMatcherImpl(i, E.left(i));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.value = value;
const valueTags = fields => {
  const match = tagsExhaustive(fields)(new TypeMatcherImpl([]));
  return input => match(input);
};
/**
 * @category constructors
 * @since 1.0.0
 */
exports.valueTags = valueTags;
const typeTags = () => fields => {
  const match = tagsExhaustive(fields)(new TypeMatcherImpl([]));
  return input => match(input);
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.typeTags = typeTags;
const when = (pattern, f) => self => self.add(new When(makePredicate(pattern), f));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.when = when;
const whenOr = (...args) => self => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(new When(makeOrPredicate(patterns), onMatch));
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.whenOr = whenOr;
const whenAnd = (...args) => self => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(new When(makeAndPredicate(patterns), onMatch));
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.whenAnd = whenAnd;
const discriminator = field => (...pattern) => {
  const f = pattern[pattern.length - 1];
  const values = pattern.slice(0, -1);
  const pred = values.length === 1 ? _ => _[field] === values[0] : _ => values.includes(_[field]);
  return self => self.add(new When(pred, f));
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.discriminator = discriminator;
const discriminators = field => fields => {
  const predicates = [];
  for (const key in fields) {
    const pred = _ => _[field] === key;
    const f = fields[key];
    if (f) {
      predicates.push(new When(pred, f));
    }
  }
  const len = predicates.length;
  return self => {
    let matcher = self;
    for (let i = 0; i < len; i++) {
      matcher = matcher.add(predicates[i]);
    }
    return matcher;
  };
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.discriminators = discriminators;
const discriminatorsExhaustive = field => fields => {
  const addCases = discriminators(field)(fields);
  return matcher => exhaustive(addCases(matcher));
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.discriminatorsExhaustive = discriminatorsExhaustive;
const tag = /*#__PURE__*/discriminator("_tag");
/**
 * @category combinators
 * @since 1.0.0
 */
exports.tag = tag;
const tags = /*#__PURE__*/discriminators("_tag");
/**
 * @category combinators
 * @since 1.0.0
 */
exports.tags = tags;
const tagsExhaustive = /*#__PURE__*/discriminatorsExhaustive("_tag");
/**
 * @category combinators
 * @since 1.0.0
 */
exports.tagsExhaustive = tagsExhaustive;
const not = (pattern, f) => self => self.add(new Not(makePredicate(pattern), f));
/**
 * @since 1.0.0
 */
exports.not = not;
const SafeSchemaId = /*#__PURE__*/Symbol.for("@effect/match/SafeSchema");
/**
 * Use a schema as a predicate, marking it **unsafe**. Unsafe means it contains
 * refinements that could make the pattern not match.
 *
 * @category predicates
 * @since 1.0.0
 */
exports.SafeSchemaId = SafeSchemaId;
const unsafe = schema => schema;
/**
 * Use a schema as a predicate, marking it **safe**. Safe means **it does not**
 * contain refinements that could make the pattern not match.
 *
 * @category predicates
 * @since 1.0.0
 */
exports.unsafe = unsafe;
const safe = schema => schema;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.safe = safe;
const nonEmptyString = u => typeof u === "string" && u.length > 0;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.nonEmptyString = nonEmptyString;
const is = (...literals) => {
  const len = literals.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (u === literals[i]) {
        return true;
      }
    }
    return false;
  };
};
/**
 * @category predicates
 * @since 1.0.0
 */
exports.is = is;
const string = P.isString;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.string = string;
const number = P.isNumber;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.number = number;
const any = () => true;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.any = any;
const defined = u => u !== undefined && u !== null;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.defined = defined;
const boolean = P.isBoolean;
exports.boolean = boolean;
const _undefined = P.isUndefined;
exports.undefined = _undefined;
const _null = P.isNull;
exports.null = _null;
/**
 * @category predicates
 * @since 1.0.0
 */
const bigint = P.isBigint;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.bigint = bigint;
const date = P.isDate;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.date = date;
const record = P.isRecord;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.record = record;
const instanceOf = constructor => u => u instanceof constructor;
/**
 * @category predicates
 * @since 1.0.0
 */
exports.instanceOf = instanceOf;
const instanceOfUnsafe = instanceOf;
/**
 * @category conversions
 * @since 1.0.0
 */
exports.instanceOfUnsafe = instanceOfUnsafe;
const orElse = f => self => {
  const result = either(self);
  if (E.isEither(result)) {
    // @ts-expect-error
    return result._tag === "Right" ? result.right : f(result.left);
  }
  // @ts-expect-error
  return input => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
/**
 * @category conversions
 * @since 1.0.0
 */
exports.orElse = orElse;
const orElseAbsurd = self => orElse(() => {
  throw new Error("absurd");
})(self);
/**
 * @category conversions
 * @since 1.0.0
 */
exports.orElseAbsurd = orElseAbsurd;
const either = self => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  return input => {
    for (let i = 0; i < len; i++) {
      const _case = self.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return E.right(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return E.right(_case.evaluate(input));
      }
    }
    return E.left(input);
  };
};
/**
 * @category conversions
 * @since 1.0.0
 */
exports.either = either;
const option = self => {
  const toEither = either(self);
  if (E.isEither(toEither)) {
    return E.match(toEither, {
      onLeft: () => O.none(),
      onRight: O.some
    });
  }
  return input => E.match(toEither(input), {
    onLeft: () => O.none(),
    onRight: _ => O.some(_)
  });
};
/**
 * @category conversions
 * @since 1.0.0
 */
exports.option = option;
const exhaustive = self => {
  const toEither = either(self);
  if (E.isEither(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error("@effect/match: exhaustive absurd");
  }
  return u => {
    // @ts-expect-error
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error("@effect/match: exhaustive absurd");
  };
};
exports.exhaustive = exhaustive;
//# sourceMappingURL=index.js.map