/**
 * @since 1.0.0
 */
import * as E from "@effect/data/Either";
import * as O from "@effect/data/Option";
import type { Pipeable } from "@effect/data/Pipeable";
import type { Predicate, Refinement } from "@effect/data/Predicate";
import type { Unify } from "@effect/data/Unify";
import type { ExtractMatch } from "@effect/match/internal/ExtractMatch";
import type { LiteralValue } from "@effect/schema/AST";
import * as S from "@effect/schema/Schema";
/**
 * @category model
 * @since 1.0.0
 */
export type Matcher<Input, Filters, RemainingApplied, Result, Provided> = TypeMatcher<Input, Filters, RemainingApplied, Result> | ValueMatcher<Input, Filters, RemainingApplied, Result, Provided>;
interface TypeMatcher<Input, Filters, Remaining, Result> extends Pipeable {
    readonly _tag: "TypeMatcher";
    readonly _input: (_: Input) => unknown;
    readonly _filters: (_: never) => Filters;
    readonly _remaining: (_: never) => Remaining;
    readonly _result: (_: never) => Result;
    readonly cases: ReadonlyArray<Case>;
    readonly add: <I, R, RA, A>(_case: Case) => TypeMatcher<I, R, RA, A>;
}
interface ValueMatcher<Input, Filters, Remaining, Result, Provided> extends Pipeable {
    readonly _tag: "ValueMatcher";
    readonly _input: (_: Input) => unknown;
    readonly _filters: (_: never) => Filters;
    readonly _result: (_: never) => Result;
    readonly provided: Provided;
    readonly value: E.Either<Remaining, Provided>;
    readonly add: <I, R, RA, A, Pr>(_case: Case) => ValueMatcher<I, R, RA, A, Pr>;
}
type Case = When | Not;
declare class When {
    readonly guard: (u: unknown) => boolean;
    readonly evaluate: (input: unknown) => any;
    readonly _tag = "When";
    constructor(guard: (u: unknown) => boolean, evaluate: (input: unknown) => any);
}
declare class Not {
    readonly guard: (u: unknown) => boolean;
    readonly evaluate: (input: unknown) => any;
    readonly _tag = "Not";
    constructor(guard: (u: unknown) => boolean, evaluate: (input: unknown) => any);
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const type: <I>() => Matcher<I, Without<never>, I, never, never>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const value: <const I>(i: I) => Matcher<I, Without<never>, I, never, I>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const valueTags: <const I, P extends { readonly [Tag in Tags<"_tag", I> & string]: (_: Extract<I, {
    readonly _tag: Tag;
}>) => any; }>(fields: P) => (input: I) => Unify<ReturnType<P[keyof P]>>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const typeTags: <I>() => <P extends { readonly [Tag in Tags<"_tag", I> & string]: (_: Extract<I, {
    readonly _tag: Tag;
}>) => any; }>(fields: P) => (input: I) => Unify<ReturnType<P[keyof P]>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const when: <R, const P extends PatternPrimitive<R> | PatternBase<R>, Fn extends (_: WhenMatch<R, P>) => unknown>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => Matcher<I, AddWithout<F, SafeSchemaR<PredToSchema<P>>>, ApplyFilters<I, AddWithout<F, SafeSchemaR<PredToSchema<P>>>>, A | ReturnType<Fn>, Pr>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const whenOr: <R, const P extends readonly (PatternPrimitive<R> | PatternBase<R>)[], Fn extends (_: WhenMatch<R, P[number]>) => unknown>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => Matcher<I, AddWithout<F, SafeSchemaR<PredToSchema<P[number]>>>, ApplyFilters<I, AddWithout<F, SafeSchemaR<PredToSchema<P[number]>>>>, A | ReturnType<Fn>, Pr>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const whenAnd: <R, const P extends readonly (PatternPrimitive<R> | PatternBase<R>)[], Fn extends (_: WhenMatch<R, UnionToIntersection<P[number]>>) => unknown>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => Matcher<I, AddWithout<F, SafeSchemaR<PredToSchema<UnionToIntersection<P[number]>>>>, ApplyFilters<I, AddWithout<F, SafeSchemaR<PredToSchema<UnionToIntersection<P[number]>>>>>, A | ReturnType<Fn>, Pr>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const discriminator: <D extends string>(field: D) => <R, P extends Tags<D, R> & string, B>(...pattern: [first: P, ...values: P[], f: (_: Extract<R, Record<D, P>>) => B]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => Matcher<I, AddWithout<F, Extract<R, Record<D, P>>>, ApplyFilters<I, AddWithout<F, Extract<R, Record<D, P>>>>, B | A, Pr>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const discriminators: <D extends string>(field: D) => <R, P extends { readonly [Tag in Tags<D, R> & string]?: ((_: Extract<R, Record<D, Tag>>) => any) | undefined; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => Matcher<I, AddWithout<F, Extract<R, Record<D, keyof P>>>, ApplyFilters<I, AddWithout<F, Extract<R, Record<D, keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const discriminatorsExhaustive: <D extends string>(field: D) => <R, P extends {
    readonly [Tag in Tags<D, R> & string]: (_: Extract<R, Record<D, Tag>>) => any;
}>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const tag: <R, P extends Tags<"_tag", R> & string, B>(...pattern: [first: P, ...values: P[], f: (_: Extract<R, Record<"_tag", P>>) => B]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => Matcher<I, AddWithout<F, Extract<R, Record<"_tag", P>>>, ApplyFilters<I, AddWithout<F, Extract<R, Record<"_tag", P>>>>, B | A, Pr>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const tags: <R, P extends { readonly [Tag in Tags<"_tag", R> & string]?: ((_: Extract<R, Record<"_tag", Tag>>) => any) | undefined; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => Matcher<I, AddWithout<F, Extract<R, Record<"_tag", keyof P>>>, ApplyFilters<I, AddWithout<F, Extract<R, Record<"_tag", keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const tagsExhaustive: <R, P extends { readonly [Tag in Tags<"_tag", R> & string]: (_: Extract<R, Record<"_tag", Tag>>) => any; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const not: <R, const P extends PatternPrimitive<R> | PatternBase<R>, Fn extends (_: Exclude<R, ExtractMatch<R, SafeSchemaR<PredToSchema<P>>>>) => unknown>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr>) => Matcher<I, AddOnly<F, WhenMatch<R, P>>, ApplyFilters<I, AddOnly<F, WhenMatch<R, P>>>, A | ReturnType<Fn>, Pr>;
/**
 * @since 1.0.0
 */
export declare const SafeSchemaId: unique symbol;
/**
 * @since 1.0.0
 */
export type SafeSchemaId = typeof SafeSchemaId;
/**
 * @category model
 * @since 1.0.0
 */
export interface SafeSchema<A, R = A> {
    readonly [SafeSchemaId]: SafeSchemaId;
    readonly _A: A;
    readonly _R: R;
}
/**
 * @since 1.0.0
 */
export declare namespace SafeSchema {
    /**
     * @since 1.0.0
     */
    type Infer<S extends {
        readonly _tag: "SafeSchema";
        readonly _A: any;
    }> = Parameters<S["_A"]>[0];
}
/**
 * Use a schema as a predicate, marking it **unsafe**. Unsafe means it contains
 * refinements that could make the pattern not match.
 *
 * @category predicates
 * @since 1.0.0
 */
export declare const unsafe: <A>(schema: S.Schema<A, A>) => SafeSchema<A, never>;
/**
 * Use a schema as a predicate, marking it **safe**. Safe means **it does not**
 * contain refinements that could make the pattern not match.
 *
 * @category predicates
 * @since 1.0.0
 */
export declare const safe: <A>(schema: S.Schema<A, A>) => SafeSchema<A, A>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const nonEmptyString: SafeSchema<string, never>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const is: <Literals extends ReadonlyArray<LiteralValue>>(...literals: Literals) => Refinement<unknown, Literals[number]>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const string: Refinement<unknown, string>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const number: Refinement<unknown, number>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const any: SafeSchema<unknown, any>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const defined: <A>(u: A) => u is A & {};
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const boolean: Refinement<unknown, boolean>;
declare const _undefined: Refinement<unknown, undefined>;
export { 
/**
 * @category predicates
 * @since 1.0.0
 */
_undefined as undefined, };
declare const _null: Refinement<unknown, null>;
export { 
/**
 * @category predicates
 * @since 1.0.0
 */
_null as null, };
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const bigint: Refinement<unknown, bigint>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const date: Refinement<unknown, Date>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const record: Refinement<unknown, {
    [k: string]: any;
    [k: symbol]: any;
}>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A) => SafeSchema<InstanceType<A>, never>;
/**
 * @category predicates
 * @since 1.0.0
 */
export declare const instanceOfUnsafe: <A extends abstract new (...args: any) => any>(constructor: A) => SafeSchema<InstanceType<A>, InstanceType<A>>;
/**
 * @category conversions
 * @since 1.0.0
 */
export declare const orElse: <RA, B>(f: (b: RA) => B) => <I, R, A, Pr>(self: Matcher<I, R, RA, A, Pr>) => [Pr] extends [never] ? (input: I) => Unify<B | A> : Unify<B | A>;
/**
 * @category conversions
 * @since 1.0.0
 */
export declare const orElseAbsurd: <I, R, RA, A, Pr>(self: Matcher<I, R, RA, A, Pr>) => [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A>;
/**
 * @category conversions
 * @since 1.0.0
 */
export declare const either: <I, F, R, A, Pr>(self: Matcher<I, F, R, A, Pr>) => [Pr] extends [never] ? (input: I) => E.Either<R, Unify<A>> : E.Either<R, Unify<A>>;
/**
 * @category conversions
 * @since 1.0.0
 */
export declare const option: <I, F, R, A, Pr>(self: Matcher<I, F, R, A, Pr>) => [Pr] extends [never] ? (input: I) => O.Option<Unify<A>> : O.Option<Unify<A>>;
/**
 * @category conversions
 * @since 1.0.0
 */
export declare const exhaustive: <I, F, A, Pr>(self: Matcher<I, F, never, A, Pr>) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A>;
type WhenMatch<R, P> = [
    0
] extends [1 & R] ? PForMatch<P> : P extends SafeSchema<infer SP, never> ? SP : P extends Refinement<infer _R, infer RP> ? [
    Extract<R, RP>
] extends [infer X] ? [X] extends [never] ? RP : X : never : P extends PredicateA<infer PP> ? PP : ExtractMatch<R, PForMatch<P>>;
type NotMatch<R, P> = Exclude<R, ExtractMatch<R, PForExclude<P>>>;
type PForMatch<P> = SafeSchemaP<ResolvePred<P>>;
type PForExclude<P> = SafeSchemaR<PredToSchema<P>>;
type PredicateA<A> = Predicate<A> | Refinement<A, A>;
type SafeSchemaP<A> = A extends never ? never : A extends SafeSchema<infer S, infer _> ? S : A extends Function ? A : A extends Record<string, any> ? {
    [K in keyof A]: SafeSchemaP<A[K]>;
} : A;
type SafeSchemaR<A> = A extends never ? never : A extends SafeSchema<infer _, infer R> ? R : A extends Function ? A : A extends Record<string, any> ? {
    [K in keyof A]: SafeSchemaR<A[K]>;
} : A;
type ResolvePred<A> = A extends never ? never : A extends Refinement<any, infer P> ? P : A extends Predicate<infer P> ? P : A extends SafeSchema<any> ? A : A extends Record<string, any> ? {
    [K in keyof A]: ResolvePred<A[K]>;
} : A;
type PredToSchema<A> = A extends never ? never : A extends Refinement<any, infer P> ? SafeSchema<P, P> : A extends Predicate<infer P> ? SafeSchema<P, never> : A extends SafeSchema<any> ? A : A extends Record<string, any> ? {
    [K in keyof A]: PredToSchema<A[K]>;
} : NonLiteralsTo<A, never>;
type NonLiteralsTo<A, T> = [A] extends [string | number | boolean | bigint] ? [string] extends [A] ? T : [number] extends [A] ? T : [boolean] extends [A] ? T : [bigint] extends [A] ? T : A : A;
type PatternBase<A> = A extends ReadonlyArray<infer _T> ? ReadonlyArray<any> | PatternPrimitive<A> : A extends Record<string, any> ? Partial<{
    [K in keyof A]: PatternPrimitive<A[K] & {}> | PatternBase<A[K] & {}>;
}> : never;
type PatternPrimitive<A> = PredicateA<A> | A | SafeSchema<any>;
interface Without<X> {
    readonly _tag: "Without";
    readonly _X: X;
}
interface Only<X> {
    readonly _tag: "Only";
    readonly _X: X;
}
type AddWithout<A, X> = [A] extends [Without<infer WX>] ? Without<X | WX> : [A] extends [Only<infer OX>] ? Only<Exclude<OX, X>> : never;
type AddOnly<A, X> = [A] extends [Without<infer WX>] ? [X] extends [WX] ? never : Only<X> : [A] extends [Only<infer OX>] ? [X] extends [OX] ? Only<X> : never : never;
type ApplyFilters<I, A> = A extends Only<infer X> ? X : A extends Without<infer X> ? Exclude<I, X> : never;
type Tags<D extends string, P> = P extends Record<D, infer X> ? X : never;
type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
type ArrayToIntersection<A extends ReadonlyArray<any>> = UnionToIntersection<A[number]>;
//# sourceMappingURL=index.d.ts.map