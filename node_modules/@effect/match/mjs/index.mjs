/**
 * @since 1.0.0
 */
import * as E from "@effect/data/Either";
import { identity } from "@effect/data/Function";
import * as O from "@effect/data/Option";
import { pipeArguments } from "@effect/data/Pipeable";
import * as P from "@effect/data/Predicate";
import * as S from "@effect/schema/Schema";
class TypeMatcherImpl {
  constructor(cases) {
    this.cases = cases;
    this._tag = "TypeMatcher";
    this._input = identity;
    this._filters = identity;
    this._remaining = identity;
    this._result = identity;
  }
  add(_case) {
    return new TypeMatcherImpl([...this.cases, _case]);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
class ValueMatcherImpl {
  constructor(provided, value) {
    this.provided = provided;
    this.value = value;
    this._tag = "ValueMatcher";
    this._input = identity;
    this._filters = identity;
    this._result = identity;
  }
  add(_case) {
    if (this.value._tag === "Right") {
      // @ts-expect-error
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return new ValueMatcherImpl(this.provided, E.right(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return new ValueMatcherImpl(this.provided, E.right(_case.evaluate(this.provided)));
    }
    // @ts-expect-error
    return this;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
class When {
  constructor(guard, evaluate) {
    this.guard = guard;
    this.evaluate = evaluate;
    this._tag = "When";
  }
}
class Not {
  constructor(guard, evaluate) {
    this.guard = guard;
    this.evaluate = evaluate;
    this._tag = "Not";
  }
}
const makePredicate = pattern => {
  if (typeof pattern === "function") {
    return pattern;
  } else if (Array.isArray(pattern)) {
    const predicates = pattern.map(makePredicate);
    const len = predicates.length;
    return u => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern !== null && typeof pattern === "object") {
    if (S.isSchema(pattern)) {
      const validate = S.validateEither(pattern);
      return u => validate(u, {
        onExcessProperty: "ignore"
      })._tag === "Right";
    }
    const keysAndPredicates = Object.entries(pattern).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return u => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return u => u === pattern;
};
const makeOrPredicate = patterns => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
};
const makeAndPredicate = patterns => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
};
/**
 * @category constructors
 * @since 1.0.0
 */
export const type = () => new TypeMatcherImpl([]);
/**
 * @category constructors
 * @since 1.0.0
 */
export const value = i => new ValueMatcherImpl(i, E.left(i));
/**
 * @category constructors
 * @since 1.0.0
 */
export const valueTags = fields => {
  const match = tagsExhaustive(fields)(new TypeMatcherImpl([]));
  return input => match(input);
};
/**
 * @category constructors
 * @since 1.0.0
 */
export const typeTags = () => fields => {
  const match = tagsExhaustive(fields)(new TypeMatcherImpl([]));
  return input => match(input);
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const when = (pattern, f) => self => self.add(new When(makePredicate(pattern), f));
/**
 * @category combinators
 * @since 1.0.0
 */
export const whenOr = (...args) => self => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(new When(makeOrPredicate(patterns), onMatch));
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const whenAnd = (...args) => self => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(new When(makeAndPredicate(patterns), onMatch));
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const discriminator = field => (...pattern) => {
  const f = pattern[pattern.length - 1];
  const values = pattern.slice(0, -1);
  const pred = values.length === 1 ? _ => _[field] === values[0] : _ => values.includes(_[field]);
  return self => self.add(new When(pred, f));
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const discriminators = field => fields => {
  const predicates = [];
  for (const key in fields) {
    const pred = _ => _[field] === key;
    const f = fields[key];
    if (f) {
      predicates.push(new When(pred, f));
    }
  }
  const len = predicates.length;
  return self => {
    let matcher = self;
    for (let i = 0; i < len; i++) {
      matcher = matcher.add(predicates[i]);
    }
    return matcher;
  };
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const discriminatorsExhaustive = field => fields => {
  const addCases = discriminators(field)(fields);
  return matcher => exhaustive(addCases(matcher));
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const tag = /*#__PURE__*/discriminator("_tag");
/**
 * @category combinators
 * @since 1.0.0
 */
export const tags = /*#__PURE__*/discriminators("_tag");
/**
 * @category combinators
 * @since 1.0.0
 */
export const tagsExhaustive = /*#__PURE__*/discriminatorsExhaustive("_tag");
/**
 * @category combinators
 * @since 1.0.0
 */
export const not = (pattern, f) => self => self.add(new Not(makePredicate(pattern), f));
/**
 * @since 1.0.0
 */
export const SafeSchemaId = /*#__PURE__*/Symbol.for("@effect/match/SafeSchema");
/**
 * Use a schema as a predicate, marking it **unsafe**. Unsafe means it contains
 * refinements that could make the pattern not match.
 *
 * @category predicates
 * @since 1.0.0
 */
export const unsafe = schema => schema;
/**
 * Use a schema as a predicate, marking it **safe**. Safe means **it does not**
 * contain refinements that could make the pattern not match.
 *
 * @category predicates
 * @since 1.0.0
 */
export const safe = schema => schema;
/**
 * @category predicates
 * @since 1.0.0
 */
export const nonEmptyString = u => typeof u === "string" && u.length > 0;
/**
 * @category predicates
 * @since 1.0.0
 */
export const is = (...literals) => {
  const len = literals.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (u === literals[i]) {
        return true;
      }
    }
    return false;
  };
};
/**
 * @category predicates
 * @since 1.0.0
 */
export const string = P.isString;
/**
 * @category predicates
 * @since 1.0.0
 */
export const number = P.isNumber;
/**
 * @category predicates
 * @since 1.0.0
 */
export const any = () => true;
/**
 * @category predicates
 * @since 1.0.0
 */
export const defined = u => u !== undefined && u !== null;
/**
 * @category predicates
 * @since 1.0.0
 */
export const boolean = P.isBoolean;
const _undefined = P.isUndefined;
export {
/**
 * @category predicates
 * @since 1.0.0
 */
_undefined as undefined };
const _null = P.isNull;
export {
/**
 * @category predicates
 * @since 1.0.0
 */
_null as null };
/**
 * @category predicates
 * @since 1.0.0
 */
export const bigint = P.isBigint;
/**
 * @category predicates
 * @since 1.0.0
 */
export const date = P.isDate;
/**
 * @category predicates
 * @since 1.0.0
 */
export const record = P.isRecord;
/**
 * @category predicates
 * @since 1.0.0
 */
export const instanceOf = constructor => u => u instanceof constructor;
/**
 * @category predicates
 * @since 1.0.0
 */
export const instanceOfUnsafe = instanceOf;
/**
 * @category conversions
 * @since 1.0.0
 */
export const orElse = f => self => {
  const result = either(self);
  if (E.isEither(result)) {
    // @ts-expect-error
    return result._tag === "Right" ? result.right : f(result.left);
  }
  // @ts-expect-error
  return input => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
/**
 * @category conversions
 * @since 1.0.0
 */
export const orElseAbsurd = self => orElse(() => {
  throw new Error("absurd");
})(self);
/**
 * @category conversions
 * @since 1.0.0
 */
export const either = self => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  return input => {
    for (let i = 0; i < len; i++) {
      const _case = self.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return E.right(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return E.right(_case.evaluate(input));
      }
    }
    return E.left(input);
  };
};
/**
 * @category conversions
 * @since 1.0.0
 */
export const option = self => {
  const toEither = either(self);
  if (E.isEither(toEither)) {
    return E.match(toEither, {
      onLeft: () => O.none(),
      onRight: O.some
    });
  }
  return input => E.match(toEither(input), {
    onLeft: () => O.none(),
    onRight: _ => O.some(_)
  });
};
/**
 * @category conversions
 * @since 1.0.0
 */
export const exhaustive = self => {
  const toEither = either(self);
  if (E.isEither(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error("@effect/match: exhaustive absurd");
  }
  return u => {
    // @ts-expect-error
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error("@effect/match: exhaustive absurd");
  };
};
//# sourceMappingURL=index.mjs.map