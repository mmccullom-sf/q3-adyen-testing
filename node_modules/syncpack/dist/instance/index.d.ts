import * as Data from '@effect/data/Data';
import * as Option from '@effect/data/Option';
import type npa from 'npm-package-arg';
import type { AliasResult, FileResult, HostedGitResult, RegistryResult, URLResult } from 'npm-package-arg';
import type { Strategy } from '../config/get-custom-types';
import type { PackageJsonFile } from '../get-package-json-files/package-json-file';
import { type Delete } from '../get-version-groups/lib/delete';
/** Extends npm/npm-package-arg to support "workspace:*" */
export interface WorkspaceProtocolResult {
    type: 'workspaceProtocol';
    raw: string;
    name: string | null;
    escapedName: string | null;
    scope: string | null;
    rawSpec: string;
    saveSpec: string;
}
export type NpmPackageArgResult = ReturnType<typeof npa.resolve> | WorkspaceProtocolResult;
interface BaseInstance<T extends NpmPackageArgResult | unknown> {
    /** the name of this dependency */
    name: string;
    /** The package this dependency is installed in this specific time */
    packageJsonFile: PackageJsonFile;
    /** @see https://github.com/npm/npm-package-arg */
    parsedSpecifier: T;
    /** The .name property of the package.json file of this instance */
    pkgName: string;
    /** The raw: semver, git, workspace: etc version value */
    specifier: string;
    /** locates where in the file this dependency is installed */
    strategy: Strategy.Any;
}
export declare namespace Instance {
    /**
     * A helper to create specific classes for each of the possible
     * `RegistryResult` types from npm/npm-package-arg. Instead of grouping them
     * together we are being more specific
     */
    type SpecificRegistryResult<T extends RegistryResult['type'] | 'localPackage'> = Omit<RegistryResult, 'type'> & {
        type: T;
    };
    const FileInstance_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "FileInstance";
    }>;
    /** An `Instance` whose specifier is a path to a local file or directory */
    export class FileInstance extends FileInstance_base<BaseInstance<FileResult>> {
        setSpecifier: typeof setSpecifier;
        getSemverSpecifier(): Option.Option<string>;
    }
    const HostedGitInstance_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "HostedGitInstance";
    }>;
    /** An `Instance` whose specifier is a Git URL */
    export class HostedGitInstance extends HostedGitInstance_base<BaseInstance<HostedGitResult>> {
        setSpecifier: typeof setSpecifier;
        getSemverSpecifier(): Option.Option<string>;
    }
    const UrlInstance_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "URLInstance";
    }>;
    /** An `Instance` whose specifier is a URL to a tarball */
    export class UrlInstance extends UrlInstance_base<BaseInstance<URLResult>> {
        setSpecifier: typeof setSpecifier;
        getSemverSpecifier(): Option.Option<string>;
    }
    const AliasInstance_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "AliasInstance";
    }>;
    /** An `Instance` whose specifier is eg "npm:imageoptim-cli@3.1.7" */
    export class AliasInstance extends AliasInstance_base<BaseInstance<AliasResult>> {
        setSpecifier(version: string | Delete): void;
        getSemverSpecifier(): Option.Option<string>;
    }
    const VersionInstance_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "VersionInstance";
    }>;
    /** An `Instance` whose specifier is exact semver */
    export class VersionInstance extends VersionInstance_base<BaseInstance<SpecificRegistryResult<'version'>>> {
        setSpecifier: typeof setSpecifier;
        getSemverSpecifier(): Option.Option<string>;
    }
    const RangeInstance_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "RangeInstance";
    }>;
    /** An `Instance` whose specifier is eg. "*" or "^1.2.3" */
    export class RangeInstance extends RangeInstance_base<BaseInstance<SpecificRegistryResult<'range'>>> {
        setSpecifier: typeof setSpecifier;
        getSemverSpecifier(): Option.Option<string>;
    }
    const TagInstance_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "TagInstance";
    }>;
    /** An `Instance` whose specifier is eg. "latest" or "made-up-by-some-dev" */
    export class TagInstance extends TagInstance_base<BaseInstance<SpecificRegistryResult<'tag'>>> {
        setSpecifier: typeof setSpecifier;
        getSemverSpecifier(): Option.Option<string>;
    }
    const WorkspaceProtocolInstance_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "WorkspaceProtocolInstance";
    }>;
    /** An `Instance` whose specifier is "workspace:*" */
    export class WorkspaceProtocolInstance extends WorkspaceProtocolInstance_base<BaseInstance<WorkspaceProtocolResult>> {
        setSpecifier: typeof setSpecifier;
        getSemverSpecifier(): Option.Option<string>;
    }
    const UnsupportedInstance_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "UnsupportedInstance";
    }>;
    /** An `Instance` whose specifier is not supported by npm */
    export class UnsupportedInstance extends UnsupportedInstance_base<BaseInstance<unknown>> {
        setSpecifier: typeof setSpecifier;
        getSemverSpecifier(): Option.Option<string>;
    }
    export type Any = FileInstance | HostedGitInstance | UrlInstance | AliasInstance | VersionInstance | RangeInstance | TagInstance | WorkspaceProtocolInstance | UnsupportedInstance;
    export {};
}
/**
 * In the case of banned dependencies, their version is set to `undefined`,
 * which causes them to be removed by `JSON.stringify`.
 */
declare function setSpecifier(this: Instance.Any, version: string | Delete): void;
export {};
