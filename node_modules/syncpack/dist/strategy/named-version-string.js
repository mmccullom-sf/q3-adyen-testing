"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamedVersionStringStrategy = void 0;
const Function_1 = require("@effect/data/Function");
const get_1 = require("tightrope/fn/get");
const is_non_empty_string_1 = require("tightrope/guard/is-non-empty-string");
const result_1 = require("tightrope/result");
const and_then_1 = require("tightrope/result/and-then");
const from_try_1 = require("tightrope/result/from-try");
const map_1 = require("tightrope/result/map");
const tap_1 = require("tightrope/result/tap");
const delete_1 = require("../get-version-groups/lib/delete");
const get_non_empty_string_prop_1 = require("./lib/get-non-empty-string-prop");
class NamedVersionStringStrategy {
    constructor(name, path) {
        this._tag = 'name@version';
        this.name = name;
        this.path = path;
    }
    read(file) {
        const path = this.path;
        return (0, Function_1.pipe)(
        // get version prop
        (0, get_non_empty_string_prop_1.getNonEmptyStringProp)(path, file), 
        // if it is a non empty string, we can read it
        (0, and_then_1.andThen)((value) => {
            const [name, version] = value.split(/@(.*)/);
            return (0, is_non_empty_string_1.isNonEmptyString)(name) && (0, is_non_empty_string_1.isNonEmptyString)(version)
                ? new result_1.Ok([[name, version]])
                : new result_1.Err(new Error(`Strategy<name@version> failed to get ${path} in ${file.shortPath}`));
        }));
    }
    write(file, [name, version]) {
        const { contents } = file;
        const path = this.path;
        const isNestedPath = path.includes('.');
        const nextValue = version === delete_1.DELETE ? undefined : `${name}@${version}`;
        if (isNestedPath) {
            const fullPath = path.split('.');
            const pathToParent = fullPath.slice(0, fullPath.length - 1).join('.');
            const key = fullPath.slice(-1).join('');
            return (0, Function_1.pipe)((0, get_1.get)(contents, ...pathToParent.split('.')), (0, tap_1.tap)((parent) => {
                parent[key] = nextValue;
            }), (0, map_1.map)(() => file));
        }
        else {
            return (0, Function_1.pipe)((0, from_try_1.fromTry)(() => {
                contents[path] = nextValue;
            }), (0, map_1.map)(() => file));
        }
    }
}
exports.NamedVersionStringStrategy = NamedVersionStringStrategy;
