"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NameAndVersionPropsStrategy = void 0;
const Function_1 = require("@effect/data/Function");
const get_1 = require("tightrope/fn/get");
const and_then_1 = require("tightrope/result/and-then");
const from_try_1 = require("tightrope/result/from-try");
const map_1 = require("tightrope/result/map");
const tap_1 = require("tightrope/result/tap");
const delete_1 = require("../get-version-groups/lib/delete");
const get_non_empty_string_prop_1 = require("./lib/get-non-empty-string-prop");
class NameAndVersionPropsStrategy {
    constructor(name, path, namePath) {
        this._tag = 'name~version';
        this.name = name;
        this.path = path;
        this.namePath = namePath;
    }
    read(file) {
        const path = this.path;
        const namePath = this.namePath;
        return (0, Function_1.pipe)(
        // get name prop
        (0, get_non_empty_string_prop_1.getNonEmptyStringProp)(namePath, file), 
        // add the version prop
        (0, and_then_1.andThen)((name) => (0, Function_1.pipe)((0, get_non_empty_string_prop_1.getNonEmptyStringProp)(path, file), (0, map_1.map)((version) => ({ name, version })))), 
        // if both are non empty strings, we can return them
        (0, map_1.map)(({ name, version }) => [[name, version]]));
    }
    write(file, [, version]) {
        const path = this.path;
        const { contents } = file;
        const isNestedPath = path.includes('.');
        const nextValue = version === delete_1.DELETE ? undefined : version;
        if (isNestedPath) {
            const fullPath = path.split('.');
            const pathToParent = fullPath.slice(0, fullPath.length - 1).join('.');
            const key = fullPath.slice(-1).join('');
            return (0, Function_1.pipe)((0, get_1.get)(contents, ...pathToParent.split('.')), (0, tap_1.tap)((parent) => {
                parent[key] = version;
            }), (0, map_1.map)(() => file));
        }
        else {
            return (0, Function_1.pipe)((0, from_try_1.fromTry)(() => {
                contents[path] = nextValue;
            }), (0, map_1.map)(() => file));
        }
    }
}
exports.NameAndVersionPropsStrategy = NameAndVersionPropsStrategy;
