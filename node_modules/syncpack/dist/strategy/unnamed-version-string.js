"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnnamedVersionStringStrategy = void 0;
const Function_1 = require("@effect/data/Function");
const get_1 = require("tightrope/fn/get");
const from_try_1 = require("tightrope/result/from-try");
const map_1 = require("tightrope/result/map");
const tap_1 = require("tightrope/result/tap");
const delete_1 = require("../get-version-groups/lib/delete");
const get_non_empty_string_prop_1 = require("./lib/get-non-empty-string-prop");
class UnnamedVersionStringStrategy {
    constructor(name, path) {
        this._tag = 'version';
        this.name = name;
        this.path = path;
    }
    read(file) {
        const path = this.path;
        return (0, Function_1.pipe)(
        // get version prop
        (0, get_non_empty_string_prop_1.getNonEmptyStringProp)(path, file), 
        // if it is a non empty string, we can read it
        (0, map_1.map)((version) => {
            const name = path.split('.').slice(-1).join('');
            return [[name, version]];
        }));
    }
    write(file, [, version]) {
        const path = this.path;
        const { contents } = file;
        const isNestedPath = path.includes('.');
        const nextValue = version === delete_1.DELETE ? undefined : version;
        if (isNestedPath) {
            const fullPath = path.split('.');
            const pathToParent = fullPath.slice(0, fullPath.length - 1).join('.');
            const key = fullPath.slice(-1).join('');
            return (0, Function_1.pipe)((0, get_1.get)(contents, ...pathToParent.split('.')), (0, tap_1.tap)((parent) => {
                parent[key] = nextValue;
            }), (0, map_1.map)(() => file));
        }
        else {
            return (0, Function_1.pipe)((0, from_try_1.fromTry)(() => {
                contents[path] = nextValue;
            }), (0, map_1.map)(() => file));
        }
    }
}
exports.UnnamedVersionStringStrategy = UnnamedVersionStringStrategy;
