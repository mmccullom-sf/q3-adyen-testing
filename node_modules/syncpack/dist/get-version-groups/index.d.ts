import * as Data from '@effect/data/Data';
import * as Effect from '@effect/io/Effect';
import type { Union } from 'ts-toolbelt';
import type { DeprecatedTypesError } from '../config/get-enabled-types';
import type { Ctx } from '../get-context';
import type { Instance } from '../instance';
import { BannedVersionGroup } from './banned';
import { FilteredOutVersionGroup } from './filtered-out';
import { IgnoredVersionGroup } from './ignored';
import { PinnedVersionGroup } from './pinned';
import { SameRangeVersionGroup } from './same-range';
import { SnappedToVersionGroup } from './snapped-to';
import { StandardVersionGroup } from './standard';
export type AnyVersionGroup = Union.Strict<BannedVersionGroup | FilteredOutVersionGroup | IgnoredVersionGroup | PinnedVersionGroup | SameRangeVersionGroup | SnappedToVersionGroup | StandardVersionGroup>;
export declare namespace VersionGroupReport {
    const Banned_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "Banned";
    }>;
    /**
     * Every instance in this `BannedVersionGroup` matched its configuration and
     * will be removed if fixed
     */
    export class Banned extends Banned_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: false;
    }> {
    }
    const FilteredOut_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "FilteredOut";
    }>;
    /**
     * Every instance in this `FilteredOutVersionGroup` has name which does not
     * match the RegExp produced by the `--filter` option.
     */
    export class FilteredOut extends FilteredOut_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: true;
    }> {
    }
    const HighestSemverMismatch_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "HighestSemverMismatch";
    }>;
    /**
     * One or more instances has a version which is not identical to the others,
     * to resolve this issue the highest semver version present should be used
     */
    export class HighestSemverMismatch extends HighestSemverMismatch_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: false;
        readonly expectedVersion: string;
    }> {
    }
    const Ignored_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "Ignored";
    }>;
    /**
     * Every instance in this `IgnoredVersionGroup` matched its configuration
     */
    export class Ignored extends Ignored_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: true;
    }> {
    }
    const LowestSemverMismatch_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "LowestSemverMismatch";
    }>;
    /**
     * One or more instances has a version which is not identical to the others,
     * to resolve this issue the lowest semver version present should be used
     */
    export class LowestSemverMismatch extends LowestSemverMismatch_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: false;
        readonly expectedVersion: string;
    }> {
    }
    const PinnedMismatch_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "PinnedMismatch";
    }>;
    /**
     * One or more instances has a version which is not identical to the
     * `pinVersion` value set in this `PinnedVersionGroup`
     */
    export class PinnedMismatch extends PinnedMismatch_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: false;
        readonly expectedVersion: string;
    }> {
    }
    const SameRangeMismatch_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "SameRangeMismatch";
    }>;
    /**
     * One or more instances has a version which is not satisfied by the semver
     * version ranges defined by every other instance of this same dependency. In
     * a `SameRangeVersionGroup`, each version does not have to be indentical, but
     * they do have to all satisfy the ranges set by the others.
     */
    export class SameRangeMismatch extends SameRangeMismatch_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: false;
    }> {
    }
    const SnappedToMismatch_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "SnappedToMismatch";
    }>;
    /**
     * One or more instances has a version which does not match the version used
     * in any of the locally developed packages whose names are set in the
     * `snapTo` array of this `SnappedToVersionGroup`
     */
    export class SnappedToMismatch extends SnappedToMismatch_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: false;
        readonly expectedVersion: string;
        readonly snapTo: string[];
    }> {
    }
    const NonSemverMismatch_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "NonSemverMismatch";
    }>;
    /**
     * One or more instances has a version which does not match the others and
     * also, at least one of the instances has a version which is not semver.
     * Syncpack cannot guess what any given Developer will want to do in this
     * situation
     */
    export class NonSemverMismatch extends NonSemverMismatch_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: false;
    }> {
    }
    const Valid_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "Valid";
    }>;
    /**
     * Every instance satisfies the rules of the Version Group they belong to
     */
    export class Valid extends Valid_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: true;
    }> {
    }
    const LocalPackageMismatch_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "LocalPackageMismatch";
    }>;
    /**
     * This dependency is one of the packages developed in this monorepo and one
     * or more of the packages in this monorepo depend on it with a version which
     * is not identical to the `.version` property of its package.json file
     */
    export class LocalPackageMismatch extends LocalPackageMismatch_base<{
        name: string;
        instances: Instance.Any[];
        readonly isValid: false;
        readonly expectedVersion: string;
        readonly localPackageInstance: Instance.Any;
    }> {
    }
    export type ValidCases = Union.Strict<FilteredOut | Ignored | Valid>;
    export type InvalidCases = Union.Strict<Banned | HighestSemverMismatch | LowestSemverMismatch | PinnedMismatch | SameRangeMismatch | SnappedToMismatch | NonSemverMismatch | LocalPackageMismatch>;
    export type FixableCases = Union.Strict<HighestSemverMismatch | LowestSemverMismatch | PinnedMismatch | SnappedToMismatch | LocalPackageMismatch>;
    export type UnfixableCases = Union.Strict<SameRangeMismatch | NonSemverMismatch | LocalPackageMismatch>;
    export type HighLowSemverMismatch = VersionGroupReport.HighestSemverMismatch | VersionGroupReport.LowestSemverMismatch;
    export type Any = Union.Strict<ValidCases | InvalidCases>;
    export {};
}
declare const VersionGroupConfigError_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
    _tag: "VersionGroupConfigError";
}>;
export declare class VersionGroupConfigError extends VersionGroupConfigError_base<{
    readonly config: unknown;
    readonly error: string;
}> {
}
export declare function getVersionGroups(ctx: Ctx): Effect.Effect<never, VersionGroupConfigError | DeprecatedTypesError, AnyVersionGroup[]>;
export {};
