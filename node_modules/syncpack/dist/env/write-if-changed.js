"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.newlines = exports.writeIfChanged = void 0;
const Function_1 = require("@effect/data/Function");
const Effect = __importStar(require("@effect/io/Effect"));
const chalk_1 = __importDefault(require("chalk"));
const os_1 = require("os");
const get_indent_1 = require("../config/get-indent");
const constants_1 = require("../constants");
const tags_1 = require("./tags");
function writeIfChanged(ctx) {
    return (0, Function_1.pipe)(tags_1.EnvTag, Effect.flatMap((env) => Effect.all(ctx.packageJsonFiles.map((file) => (0, Function_1.pipe)(Effect.Do, Effect.bind('nextJson', () => toJson(file)), Effect.bind('hasChanged', ({ nextJson }) => Effect.succeed(file.json !== nextJson)), Effect.flatMap(({ hasChanged, nextJson }) => hasChanged
        ? (0, Function_1.pipe)(env.writeFileSync(file.filePath, nextJson), Effect.flatMap(() => Effect.sync(() => {
            console.log((0, chalk_1.default) `{green ${constants_1.ICON.tick}}`, file.shortPath);
        })))
        : Effect.sync(() => {
            console.log(chalk_1.default.dim(constants_1.ICON.skip), chalk_1.default.dim(file.shortPath));
        })))))), Effect.map(() => ctx));
    function toJson(file) {
        const contents = file.contents;
        const indent = (0, get_indent_1.getIndent)(ctx.config);
        const EOL = exports.newlines.detect(file.json);
        const source = `${JSON.stringify(contents, null, indent)}${EOL}`;
        return Effect.succeed(exports.newlines.fix(source, EOL));
    }
}
exports.writeIfChanged = writeIfChanged;
const CR = '\r';
const CRLF = '\r\n';
const LF = '\n';
exports.newlines = {
    detect(source) {
        const cr = source.split(CR).length;
        const lf = source.split(LF).length;
        const crlf = source.split(CRLF).length;
        if (cr + lf === 0)
            return os_1.EOL;
        if (crlf === cr && crlf === lf)
            return CRLF;
        if (cr > lf)
            return CR;
        return LF;
    },
    fix(source, lineEnding) {
        return source.replace(/\r\n|\n|\r/g, lineEnding);
    },
};
