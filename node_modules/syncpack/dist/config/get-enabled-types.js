"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnabledTypes = exports.DeprecatedTypesError = void 0;
const Data = __importStar(require("@effect/data/Data"));
const Effect = __importStar(require("@effect/io/Effect"));
const is_array_of_strings_1 = require("tightrope/guard/is-array-of-strings");
const is_boolean_1 = require("tightrope/guard/is-boolean");
const is_empty_array_1 = require("tightrope/guard/is-empty-array");
const is_non_empty_string_1 = require("tightrope/guard/is-non-empty-string");
const constants_1 = require("../constants");
const name_and_version_props_1 = require("../strategy/name-and-version-props");
const versions_by_name_1 = require("../strategy/versions-by-name");
const get_custom_types_1 = require("./get-custom-types");
class DeprecatedTypesError extends Data.TaggedClass('DeprecatedTypesError') {
}
exports.DeprecatedTypesError = DeprecatedTypesError;
// @TODO accept `dependencyTypes: ['**']`
// @TODO support `dependencyTypes: ['!dev']`
function getEnabledTypes({ cli, rcFile, }) {
    const enabledTypes = [];
    const enabledTypeNames = ((0, is_non_empty_string_1.isNonEmptyString)(cli.types)
        ? cli.types.split(',')
        : (0, is_array_of_strings_1.isArrayOfStrings)(rcFile.dependencyTypes)
            ? rcFile.dependencyTypes
            : []).filter(is_non_empty_string_1.isNonEmptyString);
    const useDefaults = (0, is_empty_array_1.isEmptyArray)(enabledTypeNames);
    const deprecatedTypes = constants_1.DEFAULT_CONFIG.dependencyTypes.filter((key) => (0, is_boolean_1.isBoolean)(rcFile[key]));
    if (deprecatedTypes.length > 0) {
        return Effect.fail(new DeprecatedTypesError({ types: deprecatedTypes }));
    }
    if (useDefaults || enabledTypeNames.includes('dev')) {
        enabledTypes.push(new versions_by_name_1.VersionsByNameStrategy('dev', 'devDependencies'));
    }
    if (useDefaults || enabledTypeNames.includes('overrides')) {
        enabledTypes.push(new versions_by_name_1.VersionsByNameStrategy('overrides', 'overrides'));
    }
    if (useDefaults || enabledTypeNames.includes('peer')) {
        enabledTypes.push(new versions_by_name_1.VersionsByNameStrategy('peer', 'peerDependencies'));
    }
    if (useDefaults || enabledTypeNames.includes('pnpmOverrides')) {
        enabledTypes.push(new versions_by_name_1.VersionsByNameStrategy('pnpmOverrides', 'pnpm.overrides'));
    }
    if (useDefaults || enabledTypeNames.includes('prod')) {
        enabledTypes.push(new versions_by_name_1.VersionsByNameStrategy('prod', 'dependencies'));
    }
    if (useDefaults || enabledTypeNames.includes('resolutions')) {
        enabledTypes.push(new versions_by_name_1.VersionsByNameStrategy('resolutions', 'resolutions'));
    }
    if (useDefaults || enabledTypeNames.includes('workspace')) {
        enabledTypes.push(new name_and_version_props_1.NameAndVersionPropsStrategy('localPackage', 'version', 'name'));
    }
    (0, get_custom_types_1.getCustomTypes)({ cli, rcFile }).forEach((customType) => {
        if (useDefaults || enabledTypeNames.includes(customType.name)) {
            enabledTypes.push(customType);
        }
    });
    return Effect.succeed(enabledTypes);
}
exports.getEnabledTypes = getEnabledTypes;
