import * as Data from '@effect/data/Data';
import * as Effect from '@effect/io/Effect';
import type { Union } from 'ts-toolbelt';
import type { DeprecatedTypesError } from '../config/get-enabled-types';
import type { Ctx } from '../get-context';
import type { Instance } from '../instance';
import { FilteredOutSemverGroup } from './filtered-out';
import { IgnoredSemverGroup } from './ignored';
import { WithRangeSemverGroup } from './with-range';
export type AnySemverGroup = Union.Strict<FilteredOutSemverGroup | IgnoredSemverGroup | WithRangeSemverGroup>;
export declare namespace SemverGroupReport {
    const FilteredOut_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "FilteredOut";
    }>;
    export class FilteredOut extends FilteredOut_base<{
        name: string;
        instance: Instance.Any;
        readonly isValid: true;
    }> {
    }
    const Ignored_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "Ignored";
    }>;
    export class Ignored extends Ignored_base<{
        name: string;
        instance: Instance.Any;
        readonly isValid: true;
    }> {
    }
    const Valid_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "Valid";
    }>;
    export class Valid extends Valid_base<{
        name: string;
        instance: Instance.Any;
        readonly isValid: true;
    }> {
    }
    const LocalPackageSemverRangeMismatch_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "LocalPackageSemverRangeMismatch";
    }>;
    export class LocalPackageSemverRangeMismatch extends LocalPackageSemverRangeMismatch_base<{
        name: string;
        instance: Instance.Any;
        readonly isValid: false;
        readonly expectedVersion: string;
    }> {
    }
    const SemverRangeMismatch_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "SemverRangeMismatch";
    }>;
    export class SemverRangeMismatch extends SemverRangeMismatch_base<{
        name: string;
        instance: Instance.Any;
        readonly isValid: false;
        readonly expectedVersion: string;
    }> {
    }
    const NonSemverVersion_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
        _tag: "NonSemverVersion";
    }>;
    export class NonSemverVersion extends NonSemverVersion_base<{
        name: string;
        instance: Instance.Any;
        readonly isValid: false;
    }> {
    }
    export type ValidCases = Union.Strict<FilteredOut | Ignored | Valid>;
    export type InvalidCases = Union.Strict<SemverRangeMismatch | NonSemverVersion | LocalPackageSemverRangeMismatch>;
    export type FixableCases = Union.Strict<SemverRangeMismatch | LocalPackageSemverRangeMismatch>;
    export type UnfixableCases = Union.Strict<NonSemverVersion>;
    export type Any = Union.Strict<ValidCases | InvalidCases>;
    export {};
}
declare const SemverGroupConfigError_base: new <A extends Record<string, any>>(args: Data.IsEqualTo<Omit<A, keyof import("@effect/data/Equal").Equal>, {}> extends true ? void : Omit<A, keyof import("@effect/data/Equal").Equal>) => Data.Data<A & {
    _tag: "SemverGroupConfigError";
}>;
export declare class SemverGroupConfigError extends SemverGroupConfigError_base<{
    readonly config: unknown;
    readonly error: string;
}> {
}
export declare function getSemverGroups(ctx: Ctx): Effect.Effect<never, SemverGroupConfigError | DeprecatedTypesError, AnySemverGroup[]>;
export {};
