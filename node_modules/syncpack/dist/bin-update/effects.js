"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateEffects = void 0;
const Data = __importStar(require("@effect/data/Data"));
const Function_1 = require("@effect/data/Function");
const Effect = __importStar(require("@effect/io/Effect"));
const Schema = __importStar(require("@effect/schema/Schema"));
const chalk_1 = __importDefault(require("chalk"));
const https_1 = __importDefault(require("https"));
const ora_1 = __importDefault(require("ora"));
const prompts_1 = __importDefault(require("prompts"));
const unwrap_1 = require("tightrope/result/unwrap");
const constants_1 = require("../constants");
const get_highest_version_1 = require("../get-version-groups/lib/get-highest-version");
const get_unique_specifiers_1 = require("../get-version-groups/lib/get-unique-specifiers");
const log_verbose_1 = require("../lib/log-verbose");
const set_semver_range_1 = require("../lib/set-semver-range");
let spinner;
let fetchCount = 0;
exports.updateEffects = {
    onFilteredOut() {
        return Effect.unit;
    },
    onIgnored() {
        return Effect.unit;
    },
    onValid(input) {
        return fetchPackageVersions(input);
    },
    onBanned() {
        return Effect.unit;
    },
    onHighestSemverMismatch(input) {
        return fetchPackageVersions(input);
    },
    onLowestSemverMismatch() {
        return Effect.unit;
    },
    onPinnedMismatch() {
        return Effect.unit;
    },
    onSameRangeMismatch(input) {
        return fetchPackageVersions(input);
    },
    onSnappedToMismatch() {
        return Effect.unit;
    },
    onNonSemverMismatch() {
        return Effect.unit;
    },
    onLocalPackageMismatch() {
        return Effect.unit;
    },
    onComplete(ctx, results) {
        return promptForUpdates(results);
    },
};
const safeGetVersion = Schema.parseEither(Schema.struct({
    'dist-tags': Schema.struct({ latest: Schema.string }),
    'time': Schema.record(Schema.string, Schema.string),
}));
class HttpError extends Data.TaggedClass('HttpError') {
}
class JsonParseError extends Data.TaggedClass('JsonParseError') {
}
function fetchPackageVersions(input) {
    if (!spinner)
        spinner = (0, ora_1.default)().start();
    fetchCount++;
    spinner.text = chalk_1.default.blue(`Checked updates for ${fetchCount} dependencies`);
    return (0, Function_1.pipe)(fetchUrl(`https://registry.npmjs.org/${input.report.name}`), Effect.flatMap(safeGetVersion), Effect.map((struct) => ({
        input,
        versions: {
            all: Object.keys(struct.time).filter((key) => key !== 'modified' && key !== 'created'),
            latest: struct['dist-tags'].latest,
        },
    })), Effect.catchTags({
        HttpError(err) {
            return Effect.sync(() => {
                (0, log_verbose_1.logVerbose)(`HttpError for "${input.report.name}" ${err}`);
            });
        },
        JsonParseError(err) {
            return Effect.sync(() => {
                (0, log_verbose_1.logVerbose)(`JsonParseError for "${input.report.name}" ${err}`);
            });
        },
        ParseError(err) {
            return Effect.sync(() => {
                (0, log_verbose_1.logVerbose)(`ParseError for "${input.report.name}" ${err}`);
            });
        },
    }));
}
function promptForUpdates(results) {
    spinner.stop();
    return (0, Function_1.pipe)(Effect.Do, Effect.bind('choices', () => Effect.sync(() => results.reduce((arr, result) => {
        if (!result)
            return arr;
        if (!['SameRange', 'Standard'].includes(result.input.group._tag))
            return arr;
        const input = result.input;
        const latestVersion = result.versions.latest;
        const uniqueVersions = (0, get_unique_specifiers_1.getUniqueSpecifiers)(input.report.instances).map((i) => i.specifier);
        const highestVersion = (0, unwrap_1.unwrap)((0, get_highest_version_1.getHighestVersion)(uniqueVersions));
        const exactHighestVersion = (0, set_semver_range_1.setSemverRange)('', highestVersion);
        if (exactHighestVersion === latestVersion)
            return arr;
        const semverRange = (0, set_semver_range_1.getSemverRange)(highestVersion);
        const latestWithRange = (0, set_semver_range_1.setSemverRange)(semverRange, latestVersion);
        arr.push({
            result,
            selected: true,
            title: (0, chalk_1.default) `NAME {red OLD} ARROW {green NEW}`
                .replace('NAME', input.report.name)
                .replace('OLD', uniqueVersions.join(chalk_1.default.dim(', ')))
                .replace('ARROW', constants_1.ICON.rightArrow)
                .replace('NEW', latestWithRange),
        });
        return arr;
    }, []))), Effect.bind('chosenUpdates', ({ choices }) => Effect.tryPromise({
        try: () => (0, prompts_1.default)([
            {
                name: 'indexes',
                type: 'multiselect',
                message: 'Choose which packages to upgrade',
                instructions: true,
                // @ts-expect-error optionsPerPage *does* exist https://github.com/terkelg/prompts#options-7
                optionsPerPage: 50,
                choices: choices,
            },
        ])
            .then(({ indexes = [] }) => ({ choices, indexes }))
            .then(({ choices, indexes }) => indexes.map((i) => choices[i].result)),
        catch: () => new Error('Prompt failed'),
    })), Effect.flatMap(({ chosenUpdates }) => Effect.sync(() => {
        chosenUpdates.forEach(({ input, versions }) => {
            input.report.instances.forEach((instance) => {
                const semverRange = (0, set_semver_range_1.getSemverRange)(instance.specifier);
                const latestWithRange = (0, set_semver_range_1.setSemverRange)(semverRange, versions.latest);
                instance.setSpecifier(latestWithRange);
            });
        });
    })), Effect.catchAll(() => Effect.unit));
}
// @TODO: add a cache with a short TTL on disk in $TMPDIR
function fetchUrl(url) {
    return (0, Function_1.pipe)(Effect.async((resume) => {
        https_1.default
            .get(url, (res) => {
            let body = '';
            res.setEncoding('utf8');
            res.on('data', (chunk) => {
                body = `${body}${chunk}`;
            });
            res.on('end', () => {
                resume(Effect.succeed(body));
            });
        })
            .on('error', (err) => {
            resume(Effect.fail(new HttpError({ error: String(err) })));
        });
    }), Effect.flatMap((body) => Effect.try({
        try: () => JSON.parse(body),
        catch: (err) => new JsonParseError({ error: String(err) }),
    })));
}
